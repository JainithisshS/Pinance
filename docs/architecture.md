# Agentic Finance System – Architecture Overview

## 1. High-Level Components

- **Backend (FastAPI, Python)**
  - Exposes REST APIs for ingestion, analysis, news understanding, and final recommendations.
  - Implements three logical agents (A/B/C) plus a small RAG engine.

- **Database (SQLite)**
  - Local `transactions.db` file.
  - `transactions` table stores parsed transaction records.

- **ML Model (Category Classifier)**
  - Scikit-learn pipeline (TF‑IDF + Logistic Regression) trained on synthetic SMS-like data.
  - Predicts a spending category for each raw notification.

- **Android Client (Concept + Folder)**
  - Reads/pastes bank/UPI notifications and sends them to the backend.
  - Designed to integrate with all backend agents.

- **RAG Demo Module**
  - Tiny in-memory finance knowledge base.
  - Simple `retrieve(query)` function to demonstrate Retrieval-Augmented Generation.

---

## 2. Backend Architecture

### 2.1 API Layer (FastAPI Routers)

- `transactions` router (`backend/routers/transactions.py`)
  - `POST /api/parse_message`
    - Input: `raw_message` (SMS / notification text) + optional `timestamp`.
    - Logic:
      - Regex-based extraction of `amount` and `merchant`.
      - Rule-based category inference using keyword maps (Food & Dining, Transport, etc.).
      - ML-based refinement using `category_model.joblib` with a confidence threshold.
      - Persists the structured transaction into SQLite and returns it with `id`.
  - `GET /api/health`
    - Simple health-check endpoint.

- `finance_analysis` router – **Agent A** (`backend/routers/finance_analysis.py`)
  - `POST /api/analyze_finance`
    - Input: `start_date`, `end_date`.
    - Logic:
      - Queries `transactions` between the given dates.
      - Computes:
        - `total_spent`
        - `transactions_count`
        - `top_category` (most frequent category)
      - Derives a naive `risk_level` (low/medium/high) based on total spending.
      - Returns a structured `summary` + human-readable `message`.

- `news_analysis` router – **Agent B** (`backend/routers/news_analysis.py`)
  - `POST /api/analyze_news`
    - Input: `topic` (e.g., "stocks", "IT sector").
    - Logic:
      - Generates a few mock news headlines for the topic.
      - Applies keyword-based sentiment rules to classify each as positive, negative, or neutral.
      - Aggregates into `overall_sentiment`, `sentiment_breakdown`, `sample_articles`, and `summary`.

- `recommendation` router – **Agent C** (`backend/routers/recommendation.py`)
  - `POST /api/synthesize`
    - Input: `finance_insight` (from Agent A), `news_insight` (from Agent B).
    - Logic:
      - Builds a query string from both insights.
      - Calls the RAG engine (`rag_engine.retrieve`) to fetch relevant finance tips.
      - Creates a consolidated `recommendation`, a `rationale` explaining how data + news + knowledge were used, and returns the retrieved knowledge snippets.

### 2.2 Persistence Layer (SQLite)

- Implemented in `backend/db.py`.
- Responsibilities:
  - `init_db()` – creates the `transactions` table if it does not exist:
    - `id` (PK), `amount`, `merchant`, `category`, `currency`, `timestamp`, `raw_message`.
  - `insert_transaction(data)` – inserts a row and returns the new `id`.
  - `get_connection()` – provides a connection with row factory for query convenience.

### 2.3 ML Layer (Category Model)

- Implemented in `backend/category_model.py` and `backend/train_category_model.py`.
- Training:
  - Synthetic SMS-like dataset generated by `backend/generate_synthetic_dataset.py`.
  - TF‑IDF vectorizer + Logistic Regression classifier.
  - Saved as `category_model.joblib`.
- Inference:
  - `predict_category(text, default, min_confidence)`:
    - Loads the model lazily.
    - Uses `predict_proba` and returns the predicted label only if confidence ≥ threshold.
    - Falls back to the rule-based `default` category otherwise.

---

## 3. RAG Demo Architecture

- Module: `backend/rag/rag_engine.py`.
- Components:
  - `KnowledgeChunk` dataclass with `id`, `title`, `content`.
  - Small in-memory corpus of finance best practices (emergency fund, debt management, diversification).
  - `_score(query, chunk)` – keyword-overlap scoring function.
  - `retrieve(query, k)` – returns top‑k relevant chunks (or defaults) to mimic RAG retrieval.
- Integration:
  - Used by Agent C (`/api/synthesize`) to ground recommendations in explicit knowledge.

This approach demonstrates how RAG fits into the architecture without external APIs or vector databases, suitable for an offline student project.

---

## 4. Android Client Architecture (Conceptual)

- Documented in `android/README.md`.
- Main responsibilities:
  - **Manual input flow**:
    - User pastes an SMS into the app.
    - App calls `/api/parse_message` via Retrofit and displays parsed transaction.
  - **Automatic notification flow** (NotificationListenerService):
    - Listens for bank/UPI notifications.
    - Extracts title + text → `raw_message`.
    - Sends to `/api/parse_message` in the background.

This illustrates how a real mobile app would feed data into the backend and later display outputs from Agents A, B, and C.

---

## 5. Agent Orchestration (End-to-End Story)

1. **Ingestion** – Notifications/SMS → Android app → `/api/parse_message` → SQLite `transactions`.
2. **Personal Finance Analysis (Agent A)** – `/api/analyze_finance` reads `transactions` and summarizes spending + risk.
3. **News & Market Analysis (Agent B)** – `/api/analyze_news` analyzes topic sentiment from mock headlines.
4. **Decision & RAG (Agent C)** – `/api/synthesize` combines A + B with retrieved finance tips to return a grounded recommendation.

This pipeline demonstrates an end-to-end agentic system: structured personal data + external signals + knowledge base → actionable financial guidance.
